<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>《数据结构与算法JavaScript描述》学习笔记（二）—--—散列 | lazySheep blog</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><script src="/js/third-party/jquery.min.js">           </script><script src="/js/third-party/velocity.min.js">           </script><script src="/js/third-party/velocity.ui.min.js">           </script><link rel="icon" href="/img/favicon.ico"></head><body><nav id="nav-bar"><nav class="clear-fix" id="nav-container"><div class="pull-left" id="page-home"><a href="/">lazySheep blog</a></div><i class="fa fa-bars pull-right" id="toggle-nav" aria-hidden="true"></i><ul class="pull-right" id="navs"><li><a class="nav" href="/">Home</a></li><li><a class="nav" href="/about">About</a></li><li><a class="nav" href="/tags">Tags</a></li></ul></nav></nav><header id="header-info"><div id="header-container"><div id="site-info"><div id="terminal-pl"><div id="top-bar"><ul id="control"><li class="btn"></li><li class="btn"></li><li class="btn"></li></ul><div id="file-path"><i class="fa fa-folder folder-ic" aria-hidden="true"></i> lazysheep 10 X 10</div></div><div id="code-pl">Last updated: 2017-07-10<br>lazysheep:~ Desktop$ <span class="code-pl-input">node 《数据结构与算法JavaScript描述》学习笔记（二）—--—散列.js</span><br><br>> Post.tags <br><a class="tag" href="#JavaScript"><span>JavaScript</span></a><a class="tag" href="#数据结构"><span>数据结构</span></a><br><br>> Post.prev <br><a href="/2017/07/18/《数据结构与算法JavaScript描述》学习笔记（三）—-—集合-md/"><span class="answer">《数据结构与算法JavaScript描述》学习笔记（三）—-—集合</span></a><br><br>> Post.next <br><a href="/2017/07/03/《数据结构与算法JavaScript描述》学习笔记（一）—-—链表/"><span class="answer">《数据结构与算法JavaScript描述》学习笔记（一）—--—链表</span></a></div></div></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><a class="article-title">《数据结构与算法JavaScript描述》学习笔记（二）—--—散列</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-07-10</time><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong> 哈希表 </strong> （Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过 <strong> 把关键码值映射到表中一个位置 </strong> 来访问记录，以加快查找的速度。这个映射函数叫做<strong> 散列函数 </strong> ，存放记录的数组叫做散列表。<br><img src="/img/散列表/散列表.png" alt="project"><br><a id="more"></a><br>使用哈希查找有两个步骤：</p>
<ol>
<li>使用哈希函数将被查找的键（关键码）转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是<strong>处理冲突</strong></li>
<li>有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。</li>
</ol>
<h3 id="为什么使用哈希表"><a href="#为什么使用哈希表" class="headerlink" title="为什么使用哈希表"></a>为什么使用哈希表</h3><ol>
<li>对于数组来说其优势是查找十分的方便快速，但是增添删减元素却不方便</li>
<li>对于链表来说增添删除元素方便，但是查找却不方便。</li>
<li>所哈希表可谓是结合了链表跟数组的优点，查找方便，增添删除元素也方便。</li>
</ol>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。比如举个简单的例子，使用手机号码后三位就比前三位作为key更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。</p>
<p>在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。</p>
<h3 id="正整数"><a href="#正整数" class="headerlink" title="正整数"></a>正整数</h3><p>获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>霍纳算法：当key是字符串时，先计算字符串中各个字符的unicode码值，然后进行求和，每次求和要乘上一个质数，比如31. 最后求余数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">betterHash</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> H = <span class="number">37</span>;</span><br><span class="line">	<span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123;</span><br><span class="line">		total += total * H + key.charCodeAt(i);</span><br><span class="line">	&#125;</span><br><span class="line">	total = total % <span class="keyword">this</span>.table.length;</span><br><span class="line">	<span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		total += <span class="keyword">this</span>.table.length - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(total, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为 3045982 % length = 99·313 + 97·312 + 108·311 + 108·310 = 108 + 31· (108 + 31 · (97 + 31 · (99))) % length</p>
<p>如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈西值来节省时间，比如，可以 获取每8-9个字符来获取哈希值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">betterHash</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> H = <span class="number">37</span>;</span><br><span class="line">	<span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">var</span> skip = <span class="built_in">Math</span>.max(<span class="number">1</span>, key.length);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; key.length; i+= skip) &#123;</span><br><span class="line">		total += total * H + key.charCodeAt(i);</span><br><span class="line">	&#125;</span><br><span class="line">	total = total % <span class="keyword">this</span>.table.length;</span><br><span class="line">	<span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		total += <span class="keyword">this</span>.table.length - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(total, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，对于某些情况，不同的字符串会产生相同的哈希值，这就是前面说到的哈希冲突（Hash Collisions），比如下面的四个字符串：<br><img src="/img/散列表/哈希冲突.jpg" alt="project"><br>如果我们按照每8个字符取哈希的话，就会得到一样的哈希值。</p>
<h2 id="构建一个散列表"><a href="#构建一个散列表" class="headerlink" title="构建一个散列表"></a>构建一个散列表</h2><p>我们使用一个类来表示散列表，该类包含计算散列值（关键码值）的方法、向散列中插入数据的方法、向散列中读取数据的方法、显示散列表中数据的分布的方法、以及其他一些可能会用到的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">137</span>);</span><br><span class="line">	<span class="keyword">this</span>.simpleHash = simpleHash;</span><br><span class="line">	<span class="keyword">this</span>.betterHash = betterHash</span><br><span class="line">	<span class="keyword">this</span>.showDistro = showDistro;</span><br><span class="line">	<span class="keyword">this</span>.put = put;</span><br><span class="line">	<span class="keyword">this</span>.get = get;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/lazysheep666/learn_data_structrue/blob/master/%E9%9C%8D%E7%BA%B3%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86%E6%95%A3%E5%88%97%E8%A1%A8.js" target="_blank" rel="noopener">源码地址</a></p>
</blockquote>
<h2 id="避免哈希冲突"><a href="#避免哈希冲突" class="headerlink" title="避免哈希冲突"></a>避免哈希冲突</h2><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>拉链法指实现散列表的底层数组中，每个数组元素又是一个新的数据结构，比如另一个数组，这样就能储存多个键了。使用这种技术，即使两个键散列后的值相同，依然被保存在同样的位置，只不过它们在第二个数组中的位置不一样罢了。<br>一般第二个数组被称为<strong>链</strong>。一般一个链中两个连续的单元格保存一个元素。第一个保存<strong>键值</strong>，第二个保存<strong>数据</strong>。<br><img src="/img/散列表/开链法.png" alt="project"></p>
<blockquote>
<p><a href="https://github.com/lazysheep666/learn_data_structrue/blob/master/%E6%95%A3%E5%88%97%E8%A1%A8%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86%E4%B9%8B%E5%BC%80%E9%93%BE%E6%B3%95.js" target="_blank" rel="noopener">源码地址</a></p>
</blockquote>
</article><nav id="pagination"><div class="pagination clear-fix"><div class="page-prev pull-left"><a href="/2017/07/18/《数据结构与算法JavaScript描述》学习笔记（三）—-—集合-md/"><i class="fa fa-chevron-left"> </i><span>《数据结构与算法JavaScript描述》学习笔记（三）—-—集合</span></a></div><div class="page-next pull-right"><a href="/2017/07/03/《数据结构与算法JavaScript描述》学习笔记（一）—-—链表/"><span>《数据结构与算法JavaScript描述》学习笔记（一）—--—链表</span><i class="fa fa-chevron-right"></i></a></div></div></nav></div></div><footer><div id="footer-inner"><div class="social-icons"><a class="social-icon" href="https://github.com/lazysheep666" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="https://weibo.com/u/5318061001" target="_blank"><i class="fa fa-weibo"></i></a></div><p class="copyright">Copyright © lazysheep Blog undefined</p></div></footer><script src="/js/nav.js"></script><script src="/js/scroll.js"></script><script src="/js/index.js"></script></body></html>