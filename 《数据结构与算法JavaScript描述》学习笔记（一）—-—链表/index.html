<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>《数据结构与算法JavaScript描述》学习笔记（一）—--—链表 | lazySheep blog</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><script src="/js/third-party/jquery.min.js">           </script><script src="/js/third-party/velocity.min.js">           </script><script src="/js/third-party/velocity.ui.min.js">           </script><link rel="icon" href="/img/favicon.ico"></head><body><div id="header-outer"><div id="header-inner"><nav class="clear-fix" id="header-nav"><div class="pull-left" id="page-home"><a href="/">lazySheep blog</a></div><i class="fa fa-bars pull-right" id="toggle-nav" aria-hidden="true"></i><div class="pull-right" id="navs"><a class="site-page" href="/">Home</a><a class="site-page" href="/about">About</a><a class="site-page" href="/tags">Tags</a></div></nav><div id="site-info"><div id="terminal-pl"><div id="top-bar"><ul id="control"><li class="btn"></li><li class="btn"></li><li class="btn"></li></ul><div id="file-path"><i class="fa fa-folder folder-ic" aria-hidden="true"></i> lazysheep 10 X 10</div></div><div id="code-pl">Last updated: Sun May 21 09:41:00<br>Sheep:~ Desktop$ <span class="code-pl-input">node about.js</span><br><br>> Sheep.location<br><span class="anwser">'Beijng, Chongqing'</span><br><br>> Sheep.education<br><span class="anwser">'BUPT'</span><br><br>> Sheep.interests<br>[<span class="anwser">'coding', 'basketball', 'sleeping', 'reading'</span>]<br><br>> Sheep.github<br><a href="https://github.com/lazysheep666" target="_blank"><span class="answer">github.com/lazysheep666</span></a><br><br>> Sheep.email<br><a href="mailto:714201376@qq.com"><span class="answer">'mail to sheep'</span></a><br></div></div></div></div></div><div id="content-outer"><div id="content-inner"><article id="post"><a class="article-title">《数据结构与算法JavaScript描述》学习笔记（一）—--—链表</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-07-03</time><p>暑假看了下 <strong>《数据结构与算法JavaScript描述》</strong> ，这里写一下学习链表的笔记。<br><a id="more"></a></p>
<h3 id="为什么使用链表"><a href="#为什么使用链表" class="headerlink" title="为什么使用链表"></a>为什么使用链表</h3><p>JavaScript 中数组的主要问题是，它们被实现成了对象，与其他语言相比（比如 C++ 跟 Java）的数组相比，<strong>效率更低</strong>。如果你发现数组的实际使用时很慢，就可以考虑使用 <strong>链表</strong> 了。</p>
<h3 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h3><p>链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一个节点的引用叫做 <strong>链</strong> 。<br><img src="/img/链表/单链表.png" alt="project"></p>
<p>如图所示，单链表最开始包含一个 <strong>头结点</strong> （Header）作为链表的接入点，链表的表尾是一个 <strong>NULL</strong> 。</p>
<h2 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h2><p>在JavaScript中链表包含两个类。Node类用来表示节点，LinkList类提供了插入节点、删除节点、显示列表元素的方法，<br>以及一些其他辅助方法。</p>
<ul>
<li>Node类</li>
</ul>
<p>Node类包含两个属性，element用来保存节点上的数据，next用来保存指向下一个节点的链接。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.element = element;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>LinkedList类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(‘head’);</span><br><span class="line">  <span class="keyword">this</span>.find = find;</span><br><span class="line">  <span class="keyword">this</span>.insert = insert;</span><br><span class="line">  <span class="keyword">this</span>.remove = remove;</span><br><span class="line">  <span class="keyword">this</span>.display = display;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只有一个属性head，其指向头结点。<br>Head节点的next属性被初始化为null,当有新元素插入时，next会指向新的元素，所以这里没有必要修改next的值</p>
<ul>
<li>主要方法的实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>(currNode.element != item) &#123;</span><br><span class="line">    currNode = currNode.next;   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newElement, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">  newNode.next = current.next;</span><br><span class="line">  current.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>(currNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">   print(currNode.next.element);</span><br><span class="line">   currNode = currNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPrevious</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span> (!(currNode.next === <span class="literal">null</span>) &amp;&amp; (currNode.next.element != item)) &#123;</span><br><span class="line">    currNode = currNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevNode = <span class="keyword">this</span>.findPrevious(item);</span><br><span class="line">  <span class="keyword">if</span> (prevNode.next != <span class="literal">null</span>) &#123;</span><br><span class="line">    prevNode.next = prevNode.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/lazysheep666/learn_data_structrue/blob/master/%E5%8D%95%E9%93%BE%E8%A1%A8.js" target="_blank" rel="noopener">源码地址</a></p>
</blockquote>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表与单链表相比每个节点多了一个对象引用指向其的前驱。<br>如图所示<br><img src="/img/链表/双链表.png" alt="project"></p>
<blockquote>
<p><a href="https://github.com/lazysheep666/learn_data_structrue/blob/master/%E5%8F%8C%E9%93%BE%E8%A1%A8.js" target="_blank" rel="noopener">源码地址</a></p>
</blockquote>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表和单链表相似，节点类型都是一样的。唯一的区别是，在创建循环链表时，让其头结点的next属性指向它本身。<br><img src="/img/链表/循环链表.png" alt="project"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next = head;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/lazysheep666/learn_data_structrue/blob/master/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.js" target="_blank" rel="noopener">源码地址</a></p>
</blockquote>
</article><nav id="pagination"><div class="pagination clear-fix"><div class="page-prev pull-left"><a href="/《数据结构与算法JavaScript描述》学习笔记（二）—-—散列/"><i class="fa fa-chevron-left"> </i><span>《数据结构与算法JavaScript描述》学习笔记（二）—--—散列</span></a></div><div class="page-next pull-right"><a href="/node菜鸟笔记-2-Node的模块实现/"><span>node菜鸟笔记(2)---node 的模块实现</span><i class="fa fa-chevron-right"></i></a></div></div></nav></div></div><footer><div id="footer-inner"><div class="social-icons"><a class="social-icon" href="" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="" target="_blank"><i class="fa fa-weibo"></i></a><a class="social-icon" href="" target="_blank"><i class="fa fa-twitter"></i></a></div><p class="copyright">Copyright © lazysheep Blog 2017</p></div></footer><script src="/js/toggle_nav.js"></script><script src="/js/scroll.js"></script></body></html>